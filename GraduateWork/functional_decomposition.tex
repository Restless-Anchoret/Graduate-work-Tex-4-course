Чтобы решить, каким образом мы будем организовывать структуру проекта, применим принцип функциональной декомпозиции. Для этого мы ещё раз вкратце рассмотрим, какие функции приложения нам нужно реализовать, и разделим их на несколько частей. Таким образом, мы определимся, на какие модули поделить проект.

Прежде всего, мы должны предоставить пользователю возможность писать свои генераторы, валидаторы и чекеры. Очевидно, для этого необходимо написать некоторую библиотеку с методами для решения типичных операций. Также для каждого средства разработки создадим свой абстрактный класс, который нужно будет расширить, реализовав всего один метод, чтобы получить готовый генератор, валидатор или чекер, способный выполнить свою задачу. Для этих средств разработки мы будем компилировать соответствующий класс и загружать его в виртуальная машину Java прямо во время выполнения.

Тестирование посылок логично выделяется в собственный модуль. Помимо реализации распараллеливания процесса тестирования этот модуль также включит в себя интерфейс для компиляции кода и выполнения программ, написанных на определённом языке, а также две реализации этого интерфейса "--- для языков Java и C++. Разумеется, использование интерфейса позволит в дальнейшем добавлять новые его реализации для поддержки новых языков. Следуя тому же принципу, в данный модуль добавим интерфейсы, соответствующие системе оценивания и способу проверки корректности ответа.

Для работы с файлами и организации иерархии папок в файловой системе также следует отвести отдельный модуль. В нём будут реализованы все типичные операции по сохранению, просмотру, изменению и удалению файлов. Для доступа к исходному коду и соответствующему скомпилированному файлу удобно ввести отдельный интерфейс, обеспечив к ним таким образом единообразный доступ. Также в данном модуле реализуем операции по чтению и записи XML-дескрипторов.

Остаётся только выделить отдельный модуль под графический интерфейс и бизнес-логику приложения. В него мы поместим все классы, соответствующие компонентам библиотеки Swing, и классы-контроллеры, реализующие все операции, выполняемые в ответ на действия пользователя. Также в этом модуле следует разместить вспомогательные классы, реализующие некоторые интерфейсы из других модулей.